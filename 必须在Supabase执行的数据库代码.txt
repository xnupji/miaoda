-- 请复制以下所有代码，在 Supabase 后台的 SQL Editor 中运行
-- (Copy all code below and run in Supabase SQL Editor)

create table if not exists public.task_orders (
  id uuid default gen_random_uuid() primary key,
  title text not null,
  description text,
  reward numeric not null default 0,
  max_claims int,
  status text not null check (status in ('open', 'closed')) default 'open',
  created_by uuid references public.profiles(id) not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table public.task_orders
  add column if not exists image_url text;

alter table public.task_orders
  add column if not exists deadline_at timestamp with time zone;

alter table public.task_orders
  add column if not exists total_claims int default 0;

alter table public.task_orders
  add column if not exists approved_claims int default 0;

alter table public.task_orders enable row level security;

drop policy if exists "Anyone can view open task orders" on public.task_orders;
create policy "Anyone can view open task orders"
  on public.task_orders for select
  using (status = 'open');

drop policy if exists "Admins can manage all task orders" on public.task_orders;
create policy "Admins can manage all task orders"
  on public.task_orders for all
  using (
    exists (
      select 1 from public.profiles
      where profiles.id = auth.uid() and profiles.role = 'admin'
    )
  )
  with check (
    exists (
      select 1 from public.profiles
      where profiles.id = auth.uid() and profiles.role = 'admin'
    )
  );

create table if not exists public.task_order_claims (
  id uuid default gen_random_uuid() primary key,
  task_id uuid references public.task_orders(id) on delete cascade not null,
  user_id uuid references public.profiles(id) not null,
  status text not null check (status in ('claimed', 'submitted', 'approved', 'rejected')) default 'claimed',
  proof_url text,
  proof_notes text,
  receive_username text,
  receive_address text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table public.task_order_claims
  add constraint task_order_claims_unique_task_user unique (task_id, user_id);

alter table public.task_order_claims enable row level security;

drop policy if exists "Users can manage own task order claims" on public.task_order_claims;
create policy "Users can manage own task order claims"
  on public.task_order_claims for all
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

drop policy if exists "Admins can manage all task_order_claims" on public.task_order_claims;
create policy "Admins can manage all task order claims"
  on public.task_order_claims for all
  using (
    exists (
      select 1 from public.profiles
      where profiles.id = auth.uid() and profiles.role = 'admin'
    )
  )
  with check (
    exists (
      select 1 from public.profiles
      where profiles.id = auth.uid() and profiles.role = 'admin'
    )
  );

create or replace function public.handle_task_order_claim_change()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
declare
  v_task public.task_orders%rowtype;
  v_new_approved int;
begin
  if tg_op = 'INSERT' then
    update public.task_orders
    set total_claims = coalesce(total_claims, 0) + 1,
        updated_at = now()
    where id = new.task_id;
  end if;

  if tg_op = 'UPDATE' then
    if old.status is distinct from 'approved' and new.status = 'approved' then
      select *
      into v_task
      from public.task_orders
      where id = new.task_id
      for update;

      if not found then
        return new;
      end if;

      v_new_approved := coalesce(v_task.approved_claims, 0) + 1;

      update public.task_orders
      set approved_claims = v_new_approved,
          updated_at = now()
      where id = v_task.id;

      update public.profiles
      set usdt_balance = coalesce(usdt_balance, 0) + v_task.reward,
          updated_at = now()
      where id = new.user_id;

      insert into public.transactions (user_id, type, amount, token_type, status, description)
      values (
        new.user_id,
        'task_order_reward',
        v_task.reward,
        'USDT',
        'completed',
        '抢单任务奖励: ' || coalesce(v_task.title, '')
      );

      if v_task.max_claims is not null and v_new_approved >= v_task.max_claims then
        update public.task_orders
        set status = 'closed',
            updated_at = now()
        where id = v_task.id;
      end if;
    end if;
  end if;

  return new;
end;
$$;

drop trigger if exists task_order_claim_change_trigger on public.task_order_claims;

create trigger task_order_claim_change_trigger
after insert or update on public.task_order_claims
for each row
execute procedure public.handle_task_order_claim_change();
